思考题：
JQ中常用的三个筛选的方法：children(子代查找)、find(后代查找)、filter(同级过滤) =>尝试基于children的思想原理，实现find和filter

自己回去封装：
toJSON
win
find
filter
lastChild 获取最后一个元素子节点
append
insertBefore

============================================
JS中兼容性检测的三大方式：
1、TRY CATCH 异常捕获
  原理：把我们执行的代码放在TRY中尝试执行，如果没有报错说明兼容，报错说明不兼容，但是报错会执行CATCH中的代码，我们在CATCH中处理兼容即可
  前提：代码在不兼容的浏览器中执行会报错，我们才能使用这种办法

  弊端：不管当前浏览器是否支持，都需要把TRY中的代码先执行一次，这样对性能和浏览器不友好，所以一般很少用

2、检测浏览器的类型和版本号
  原理：只要我们知道当前操作不兼容什么样的浏览器(前提)，我们可以先获取当前浏览器的版本号，验证一下是否在不兼容的清单中，通过这样的判断来检测兼容即可

  window.navigator.userAgent ->获取当前浏览器的版本信息
    =>如果是IE包含 "MSIE 版本号" 这样的字符串

  思考题：回去查询JS检测浏览器的代码，分析各个浏览器版本信息的规律

3、检测当前的方法或者属性是否属于某个对象，属于就兼容，不属于就不兼容
  [第一种]
      if('getComputedStyle' in window){

      }

  [第二种]
      if(window.getComputedStyle){//->获取属性值，看是否属于undefined，属于的话条件就不成立了，反之条件成立

      }

  [第三种]
      if(typeof window.getComputedStyle!=='undefined'){

      }

===================
JS高阶编程技巧：惰性思想
=>能够执行一次就解决的，我们绝对不会执行多次
第一次给UTILS赋值的时候，执行自执行函数，形成一个不销毁的私有作用域，我们在这里就把是否兼容处理好了，存在一个私有变量中，以后在需要检测是否兼容，我们直接的使用变量即可，没必要重复的操作检测















