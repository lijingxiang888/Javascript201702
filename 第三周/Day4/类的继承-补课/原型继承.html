<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title></title>
  </head>
  <body>
    <script type="text/javascript">
//     继承：子类继承父类的属性和方法
//     比如 A类和B类 在A类中有一个say方法，B类想继承过来给B的实例使用
//     1.原型继承（原型链继承） B.prototype = new A();
//     让子类B的原型作为A类一个实例
//     2.原型继承 修改原型链查找顺序
//    3.原型继承 子类B把父类A中的公有/私有属性和方法 全部继承过来 作为子类的B的公有属性和方法
    function A() {
      this.name1 = 'zhufeng';
      this.info = function () {
        console.log('info');
      }
    }
    A.prototype.say = function () {
        console.log('my name is ' + this.name1);
    };
    B.prototype = new A();// B类的原型等于A类的实例
    function B() {

    }
//     var b1 = new B();
//     var b2 = new B();
//     console.log(b1.name1); // A的实例私有属性 'zhufeng'
//     b1.say(); // A的实例公有属性  'my name is zhufeng'
//     console.log(b2.say === b1.say);//true
//     console.log(b2.info === b1.info);//true，b1.info和b2.info都是继承A类的实例的私有属性，所以指向了同一个info，一定要和普通类的实例区分开。普通类的实例中，私有属性之间互不影响
//     console.log(b1.__proto__.__proto__.say === A.prototype.say);//true
//    //括号里面相当于  b.__proto__ // B类的实例__proto__指向了A的实例(B的原型)
    // 4.原型继承中 子类不光可以继承父类的属性和方法来使用
    // 子类也可以 修改 父类的原型上的属性和方法 但是会影响父类的其他实例 -> 子类重写父类 => 类的多态（重写）
    var b1 = new B();
    // b1.say();
    // 根据原型链找到A类原型上的say方法
    console.log(B.prototype.__proto__ === A.prototype);//true
    //  console.log(b1.__proto__.__proto__.say === A.prototype.say);
    // b1.__proto__.__proto__.say = function () {
    //   console.log('已经被B的实例所修改');
    // }
    // 子类B修改父类A的原型上属性和方法
    B.prototype.__proto__.say = function () {
      console.log('已经被B的实例所修改');
    }
    b1.say();
    var a = new A();
    a.say();
    </script>
  </body>
</html>
