<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>珠峰培训-正则</title>
</head>
<body>
<script>
    //var str = 'zhufeng2017peixun2018';

    //->test：正则的方法，验证某一个字符串是否符合某一个规则的
    //    var reg = /\d+/;//->只要"包含连续出现一个多个数字"这个规则就可以
    //    console.log(reg.test(str));//->TRUE
    //
    //    reg = /^\d+$/;//->以数字开头，以数字结尾，中间是数字(只能是数字)
    //    console.log(reg.test(str));//->FALSE

    //->表单验证：验证用户输入的内容是否符合既定的格式 (常用的正则)
    //1、手机号
    /*
     * 11位数字
     * 以1开头
     */
    //    var reg = /^1\d{10}$/;

    //2、身份证
    /*
     * 18位(前17位是数字,最后一位是数字或者X)
     * 前六位：省市县
     * 第七位到第十四位是出生年月日
     * 最后四位是顺序随机码，倒数第二位代表性别 奇数男  偶数女
     */
    //    var str = '130424199712190017';
    //    var reg = /^(\d{6})(\d{4})(\d{2})(\d{2})\d{2}(\d)(?:\d|X)$/;
    //    console.log(str.match(reg));//->match：字符串的方法,捕获到正则匹配的结果，只要加上了分组，在捕获的时候不仅把大正则匹配的捕获到，而且里面的每一个小分组(小正则)匹配的也可以单独的捕获到,如果其中有某一个分组不需要捕获(仅仅是改变优先级方便匹配),我们在分组的前面加“?:”=>只匹配不捕获   ["130424199712190017", "130424", "1997", "12", "19", "1"...]

    //3、验证是否为有效的数字
    /*
     * 整数或者负数：可以以+或者-开头，再或者没有任何的符号开头
     * 整数或者小数(如果是小数的话,必须要有点,点后面必须有数字才可以)
     * 整数部分：不能以0开头
     */
    //    var reg = /^[+-]?(\d|([1-9]\d+))(\.\d+)?$/;
    //    //-> ([1-9]\d+) 多位数不能以0开头 A
    //    //-> (\d|A) 一位数或者多位数 =>整数
    //    //-> ()? 整个小数部分出现零到一次
    //    reg = /^(\+|-)?(\d|([1-9]\d+))(\.\d+)?$/;//->如何区分是第几个分组：按照小括号左半部分从左到右数即可(不分层级)，数的过程中跳过?:、?=、?!，因为他们只匹配不捕获

    //4、验证是否为中文姓名
    /*
     * 中文汉字
     * 二到四位
     */
    //    var reg = /^[\u4e00-\u9fa5]{2,4}$/;

    //5、用户昵称
    /*
     * 数字、字母、下划线、汉字 （14个英文或者7个汉字=>一个汉字是两个字节，也就是最多14个字节）
     */
    function checkNick(nick) {
        var reg1 = /^[\u4e00-\u9fa5]$/,//->检测是否为中文
                reg2 = /^\w$/;//->检测是否为数字、字母、下划线
        var len = 0;
        for (var i = 0; i < nick.length; i++) {
            var cur = nick[i];
            if (reg1.test(cur)) {
                len += 2;
            } else if (reg2.test(cur)) {
                len++;
            } else {
                len = 0;
                break;
            }
        }
        if (len === 0 || len > 14) {
            return false;
        }
        return true;
    }

    //6、年龄
    /*
     * 18-65岁之间
     * 三个区间
     *   -> 1(8|9)   18-19
     *   -> [2-5]\d  20-59
     *   -> 6[0-5]   60-65
     */
    //    var reg = /^((1(8|9))|([2-5]\d)|(6[0-5]))$/;
    //    reg = /^((2[2-9])|(3[0-5]))$/;//->22-35


    //7、
    //邮箱的：var reg = /^\w+((-\w+)|(\.\w+))*@[A-Za-z0-9]+((\.|-)[A-Za-z0-9]+)*\.[A-Za-z0-9]+$/;
    // -> ^\w+((-\w+)|(\.\w+))*
    // @以前的部分可以是数字、字母、下划线、-、.都可以
    //   以一到多个数字、字母、下划线开头(不能以-或者.开头)
    //   -或者.不能连续出现，出现的话必须后面跟其它的
    // -> @[A-Za-z0-9]+  ：@163 / @yahoo / @zhufeng
    // -> ((\.|-)[A-Za-z0-9]+)* ：可有可无  -peixun / .com
    // -> \.[A-Za-z0-9]+ ：.com / .cn

    //URL地址的 ：http(https/ftp)://xxx.xx.xx(xxx.xxx.xx.xx):80/xxx/xxx.html
    //密码的：不能是纯数字也不能是纯字母,只能是数字字母组合在一起的(6~10位)
    //    var reg = /^(?![0-9]+$)(?![a-zA-Z]+$)[a-zA-Z0-9]{6,10}$/;
    //    var reg = /^[0-24-9]+$/;
    //    var reg = /^((?!3)\d)+$/;//->((?!3)\d) 出现一个数字但是不能是3，然后这个机制规则可以出现多次

    /*
     *分组的作用：
     * 1、可以改变正则处理时候的优先级(x|y)
     * 2、"分组捕获"：分组其实可以理解为一个大正则中分出的一个小正则，在正则捕获的时候，我们不仅仅可以把大正则匹配的结果捕获到，也可以把小分组匹配的结果捕获到
     * 3、"分组引用"：出现和前面分组一模一样的结果
     */
    //    var reg = /^18|29$/;//->这样写的话，当前的正则匹配的优先级顺序特别的乱：18、29、189、182、129、829、1829...这些都符合，而不是我们想要的18或者29
    //    var reg = /^(18|29)$/;//->只有18和29符合了

    //    var reg = /^[a-z]([a-z])\1[a-z]$/;//->\1出现和第一个分组一模一样的(内容都需要一模一样)，但是需要保证当前引用的分组能够捕获到(也就是不能加?:、?=、?!) AXXB：good、look、book、food、foot、feel、zoom...
    //    var reg = /^([a-z])([a-z])\2\1$/;//->ABBA

    /*
     * []的一些细节问题
     * 1、中括号中出现的元字符大部分都是代表的本身含义：[+-]中的+就是代表加号不是量词、[.]中的点就是小数点的意思不是任意字符了...
     *
     * 2、中括号里面不能识别两位数字：/^[18-65]$/ 它不是18-65之间，它代表 1或者8-6或者5中间的一个(这里不能8-6这样写范围,所以正则会报错)
     *
     */


</script>
</body>
</html>