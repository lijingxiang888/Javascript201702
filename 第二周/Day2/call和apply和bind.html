<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script type="text/javascript">
    // call 改变方法中的this关键字
    //     作用：将call'.'前面的this修改为call中的第一个参数值
    //          并call'.'前面的this 执行
    //    var arr1 = [1, 2, 3];
    //    var arr2 = [3, 4, 5];
    //    function fn(a, b) {
    //        console.log(this);
    //        console.log(a, b);
    //    }
    // fn.call(arr1,100,200);
    // apply 修改方法中的this关键字
    // 作用：将apply '.' 前面的this修改call中的第一个参数值
    //      并让apply '.' 前面的this执行
    //    fn.apply(arr2); // 首先fn是apply的this 将fn中的this改为arr2 并让 fn执行
    //          fn.apply(arr1, [100, 200]);
    // call和apply的区别
    //    首先call和apply都是改变方法中this关键字
    //    区别是 call传参的时候是从第二个参数开始一个一个的传递
    //    apply 把需要传递的参数值 放在一个数组里，也相当于一个一个将参数传递进去

    // bind (IE 6-8)
    //    var fe = fn.bind(arr1);
    // 预处理：事先将fn中的this修改为arr1 但并不会让fn执行，而是将改造后的fn当作返回值返回
    //    用的时候在执行
//    var arr1 = [1, 2, 3];
//    var arr2 = [3, 4, 5];
//    function fn(a, b) {
//        console.log(this);
//        console.log(a, b);
//    }
//    //    fn.call(arr1);
//    var fe = fn.bind(arr1,100,200); // fe接收的是this被改造后的fn
//    fe(); // 改造后的fn执行
    // call/apply第一个参数指定谁方法中this就是谁

//    function fn1() {
//        console.log('fn1');
//    }
//    function fn2() {
//        console.log('fn2');
//    }
//    window.fn1.call(fn2); // 让fn1执行将里面this修改为fn2
//    call'.'前面的方法执行
//    然后让'.'前面的方法里面的this 改为call中第一个参数 fn2
//    fn1.call.call.call.call() 每一个函数都可以使用Function.prototype上的call方法 因为call也是要给函数 所以就可以fn1.call.call.call.call
//    fn1.call(fn2); // fn1() 把里面this变为fn2
//    fn1.call.call(fn2);

    var obj = {
        fn: function () {
            console.log(this); // fn2
            console.log('fn');
        }
    };
//       obj.fn.call(fn2); // 让obj.fn执行 并且将里面的this改为 fn2  obj.fn => fn2.fn()
    function fn1() {
        console.log('fn1');
    }
    function fn2() {
        console.log('fn2');
    }
//       fn1.call.call(fn2);
         fn1.call.call.call.call(fn2);
//    规律
//      两个call以上最终执行的是 最后一个call中的第一个参数 里面this是window

    // 让fn1.call执行 将第一个call前面的fn1变成了fn2   fn1.call() 变成了 fn2.call()
    // 并且让fn2.call()执行  让fn2执行 里面this默认为window
    // 最终执行的就是我们fn2() 然后输出‘fn2’；


    // 最后一个call先执行 最后一个call的目的 让fn1.call执行 并且将里面的this改为 fn2  相当于 fn1.call() => fn2.call()
    //  fn2.call()让fn2执行并且将里面的this改成window
    // 最终fn2执行输出 ‘fn2’；




</script>
</body>
</html>