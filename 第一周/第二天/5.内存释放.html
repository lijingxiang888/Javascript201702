<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<button id="btn">点我</button>
<script type="text/javascript">
    // 堆内存释放
    //    浏览器默认机制 每间隔一段时间 会把那些 没有被占用的 内存回收释放

    //   自己释放
//    var obj = {name: '张建业', age: 18};
//    var obj2 = obj;
//    obj = null; // 空对象指针
//    obj2 = null;
    //    var num = null;

    //    栈内存销毁 与 不销毁
    //    window （栈内存） 关闭浏览器的时候会销毁
    //    一般情况下函数执行形成私有作用域（栈内存）执行完里面代码 就会立即销毁
//        var count = 0;
//        function fn() {
//      //   var count = 0;
//            count++;
//            console.log(count);
//        }
//        fn();//1
//        fn();//2
//        fn();//3

//        (function () {
//            var count = 0;
//            function fn() {
//              var count = 0;
//                count++;
//                console.log(count);
//            }
//            fn();//1
//            fn();//1
//            fn();//1
//        })();


    //形成不销毁栈内存
    //  在私有作用域（栈内存）中， 返回一个 引用数据类型 被外部接收 这个栈内存就不能被销毁
//        function fn() {
//            return {
//                name: '武迪',
//                mess: '别再睡觉了'
//            }
//        }
//        var f = fn(); // fn形成的栈内存理应执行完了要销毁，但是f=fn()被f引用了，所以不销毁
//        console.log(f);
    //   fn(); // 可以销毁

    //    var obj = {
    //        name: '武迪',
    //        mess: '别再睡觉了'
    //    }



    // 不立即销毁  如果返回的是一个函数数据类型 要等返回值执行完后 fn才能销毁
    /*function fn() {
        var count = 0;// 1 2
        return function () { // class = f1
            count++;
            console.log(count);
        }
    }
    console.log(fn()); // 函数返回值
    fn()(); // fn()() 让fn的返回值执行 = f1()*/


    ////////////////////////////////////////////
//
//    function fn() {
//        var count = 0;
//        function f() {
//            console.log(++count);
//        }
//        window.ff = f;
//    }
//    fn();
//    console.log(window.ff);

//    var ff;
//    function fn() {
//        var count = 0;
//        function f() {
//            console.log(++count);
//        }
//       ff = f;
//    }
//    fn();
//    console.log(ff);


//        var obj = {};
//        function fn() {
//            var count = 0;
//            function f() {
//                console.log(++count);
//            }
//           obj.ff = f;
//        }
//        fn();
//        console.log(obj.ff);

//    给元素绑定事件的时候 也会涉及到 栈内存不销毁
/*
    function fn() {
        var count = 0;
        btn.onclick = f;
        function f() {
            console.log(++count);
        }
    }
    fn();*/

//    (function () {
//        var btn = document.getElementById('btn');
//        var count = 0;
//        btn.onclick = function () {
//            console.log(++count);
//        }
//    })();

/*

        var btn = document.getElementById('btn');
         var count = 0;
        btn.onclick = function () {
            console.log(++count);
        };
*/


    function far() {
        var count = 0;// 1 2 3
        function f() {
            console.log(++count);//第一次++0 第二次++1第三次++2
        }
        return f;
    }
    var fe1 = far();
    fe1(); // 1
    fe1(); // 2
    fe1(); // 3
    far()(); // 1
    far()(); // 1
    far()(); // 1

</script>
</body>
</html>