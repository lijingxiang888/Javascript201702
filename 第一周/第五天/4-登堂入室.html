<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>珠峰培训</title>
</head>
<body>
<script>
    //    function Fn(name) {
    //        var school = '珠峰';//->school仅仅是私有作用域中的一个私有变量,在函数体中只有this.xxx=xxx才是在给实例设置私有的属性,而私有变量和实例没有必然的联系
    //        this.name = name;
    //        this.say = function () {
    //            console.log('my name is ' + this.name + ',i study in the ' + school);
    //        }
    //    }
    //    var f1 = new Fn('贾向恒');
    //    var f2 = new Fn('韩欣然');
    //    console.log(f1.name);
    //    f1.say();//->THIS指向f1
    //    console.log(f1.say === f2.say);//->FALSE 实例之间是相互独立的,this.xxx=xxx其实是给实例增加的私有的属性
    //    console.log(f1.school);//->undefined 属性名不存在,获取的结果是undefined,而不是报错  =>函数具备多种角色：普通函数、类 不同的角色之间没有必然的联系


    function Fn(name) {
        var school = '珠峰';
        this.name = name;
        this.say = function () {
            console.log('my name is ' + this.name + ',i study in the ' + school);
        };
        /*return {name: '珠峰'};*/
    }
    var f1 = new Fn('贾向恒');
    //    console.log(f1);//->实例：如果我们手动返回的结果是一个基本数据类型值，对最后的实例没有任何的影响
    //    console.log(f1);//->新的对象：如果我们手动返回的结果是一个引用数据类型的值，会把默认返回的实例给覆盖掉，此时的f1就不是类的实例了

    console.log('say' in f1);//->TRUE 检测SAY是否为F1的一个属性
    console.log(f1.hasOwnProperty('say'));//->hasOwnProperty:检测属性是否为对象(实例)的私有属性 ->TRUE
    //->in:不管当前的属性是私有的还是公有的,只要有返回的结果就是TRUE
    //->hasOwnProperty:只有是私有的属性才会返回TRUE,即使你公有里面有这个属性,但是如果私有中没有,返回结果也是FALSE

    //->检测某一个对象是否拥有某一个公有的属性:检测ATTR是否为OBJ的公有属性
    function hasPublicProperty(obj, attr) {
        return (attr in obj) && !obj.hasOwnProperty(attr);
    }
    hasPublicProperty(f1, 'say');//->FALSE
</script>
</body>
</html>